/**
 * Validation schema generator
 * Generates Zod/Yup/Joi schemas for runtime validation
 */

import { EnvVariable, ValidationLibrary, GeneratorOptions } from '../types';
import { GenerationError } from '../utils/errors';
import { EnvParser } from '../parsers/env-parser';

export class ValidationGenerator {
  private parser: EnvParser;

  constructor() {
    this.parser = new EnvParser();
  }

  /**
   * Generate validation schema based on library
   */
  public generateSchema(
    variables: EnvVariable[],
    library: ValidationLibrary,
    options: GeneratorOptions
  ): string | null {
    if (library === 'none') {
      return null;
    }

    try {
      switch (library) {
        case 'zod':
          return this.generateZodSchema(variables, options);
        case 'yup':
          return this.generateYupSchema(variables, options);
        case 'joi':
          return this.generateJoiSchema(variables, options);
        default:
          throw new GenerationError(`Unsupported validation library: ${library}`);
      }
    } catch (error) {
      throw new GenerationError(
        `Failed to generate ${library} schema: ${(error as Error).message}`
      );
    }
  }

  /**
   * Generate Zod validation schema
   */
  private generateZodSchema(variables: EnvVariable[], options: GeneratorOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Zod validation schema for environment variables');
    lines.push(' */');
    lines.push('');
    lines.push("import { z } from 'zod';");
    lines.push('');
    lines.push('export const envSchema = z.object({');

    for (let i = 0; i < variables.length; i++) {
      const variable = variables[i];
      const isLast = i === variables.length - 1;
      const isRequired = options.requiredVars.includes(variable.key) || options.strict;

      if (variable.comment) {
        lines.push(`  // ${variable.comment}`);
      }

      let zodType = this.getZodType(variable.value, options.parseTypes);

      if (!isRequired) {
        zodType = `${zodType}.optional()`;
      }

      lines.push(`  ${variable.key}: ${zodType}${isLast ? '' : ','}`);
    }

    lines.push('});');
    lines.push('');
    lines.push('export type Env = z.infer<typeof envSchema>;');
    lines.push('');
    lines.push('// Validate and export environment variables');
    lines.push('export const env = envSchema.parse(process.env);');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate Yup validation schema
   */
  private generateYupSchema(variables: EnvVariable[], options: GeneratorOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Yup validation schema for environment variables');
    lines.push(' */');
    lines.push('');
    lines.push("import * as yup from 'yup';");
    lines.push('');
    lines.push('export const envSchema = yup.object({');

    for (let i = 0; i < variables.length; i++) {
      const variable = variables[i];
      const isLast = i === variables.length - 1;
      const isRequired = options.requiredVars.includes(variable.key) || options.strict;

      if (variable.comment) {
        lines.push(`  // ${variable.comment}`);
      }

      const yupType = this.getYupType(variable.value, options.parseTypes, isRequired);
      lines.push(`  ${variable.key}: ${yupType}${isLast ? '' : ','}`);
    }

    lines.push('});');
    lines.push('');
    lines.push('export type Env = yup.InferType<typeof envSchema>;');
    lines.push('');
    lines.push('// Validate and export environment variables');
    lines.push('export const env = envSchema.validateSync(process.env);');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate Joi validation schema
   */
  private generateJoiSchema(variables: EnvVariable[], options: GeneratorOptions): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * Auto-generated by env-type-generator');
    lines.push(' * Joi validation schema for environment variables');
    lines.push(' */');
    lines.push('');
    lines.push("import Joi from 'joi';");
    lines.push('');
    lines.push('export const envSchema = Joi.object({');

    for (let i = 0; i < variables.length; i++) {
      const variable = variables[i];
      const isLast = i === variables.length - 1;
      const isRequired = options.requiredVars.includes(variable.key) || options.strict;

      if (variable.comment) {
        lines.push(`  // ${variable.comment}`);
      }

      const joiType = this.getJoiType(variable.value, options.parseTypes, isRequired);
      lines.push(`  ${variable.key}: ${joiType}${isLast ? '' : ','}`);
    }

    lines.push('});');
    lines.push('');
    lines.push('// Validate and export environment variables');
    lines.push('export const env = envSchema.validate(process.env).value;');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Get Zod type for a value
   */
  private getZodType(value: string, parseTypes: boolean): string {
    if (!parseTypes) {
      return 'z.string()';
    }

    const inferredType = this.parser.inferType(value);

    switch (inferredType) {
      case 'boolean':
        return 'z.enum(["true", "false"]).transform((val) => val === "true")';
      case 'number':
        return 'z.string().transform((val) => Number(val))';
      case 'object':
        return 'z.string().transform((val) => JSON.parse(val))';
      default:
        return 'z.string()';
    }
  }

  /**
   * Get Yup type for a value
   */
  private getYupType(value: string, parseTypes: boolean, required: boolean): string {
    const requiredSuffix = required ? '.required()' : '';

    if (!parseTypes) {
      return `yup.string()${requiredSuffix}`;
    }

    const inferredType = this.parser.inferType(value);

    switch (inferredType) {
      case 'boolean':
        return `yup.boolean()${requiredSuffix}`;
      case 'number':
        return `yup.number()${requiredSuffix}`;
      case 'object':
        return `yup.mixed()${requiredSuffix}`;
      default:
        return `yup.string()${requiredSuffix}`;
    }
  }

  /**
   * Get Joi type for a value
   */
  private getJoiType(value: string, parseTypes: boolean, required: boolean): string {
    const requiredSuffix = required ? '.required()' : '.optional()';

    if (!parseTypes) {
      return `Joi.string()${requiredSuffix}`;
    }

    const inferredType = this.parser.inferType(value);

    switch (inferredType) {
      case 'boolean':
        return `Joi.boolean()${requiredSuffix}`;
      case 'number':
        return `Joi.number()${requiredSuffix}`;
      case 'object':
        return `Joi.object()${requiredSuffix}`;
      default:
        return `Joi.string()${requiredSuffix}`;
    }
  }
}
